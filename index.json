[{"content":"20210803 读书计划\n Java 8 in Action  20210808 观影计划\n 爱在黎明破晓前, 爱在日落黄昏时, 爱在午夜降临前 迷失东京 在哥伦布  20210815 读书计划\n MySQL技术内幕  20210907 9月计划\n  Redis设计与实现\n  Mybatis源码阅读\n  ","permalink":"https://init.best/posts/plan/","summary":"My Plan Record","title":"Plan"},{"content":"Mybatis 不同类型返回值记录 resultType为string 如果select的结果为空，则dao接口返回结果为null\nresultType为基本类型，如int、double等 后台报异常： org.apache.ibatis.binding.BindingException: Mapper method \u0026lsquo;com.fkit.dao.xxDao.getUserById attempted to return null from a method with a primitive return type (int). 解释：查询结果为null，试图返回null但是方法定义的返回值是int，null转为int时报错 解决办法：\n  利用mysql的函数ifnull\n\u0026lt;select id=\u0026#34;getweekalert\u0026#34; resultType=\u0026#34;int\u0026#34;\u0026gt; select IFNULL(SUM(alert_sum),0) as alert_sum from tb_checkresults \u0026lt;/select\u0026gt;   将返回类型改为Integer等包装类型\n\u0026lt;select id=\u0026#34;getweeekalert\u0026#34; resultType=\u0026#34;Integer\u0026#34;\u0026gt; select SUM(alert_sum) as alert_sum from tb_checkresults \u0026lt;/select\u0026gt;   resultType为类为map ，如map、hashmap 　dao层接口返回值为null\nresultType 为list ，如list 　dao层接口返回值为[]，即空集合。\n注意：此时判断查询是否为空就不能用null做判断\nresultType 为类 ，如com.fkit.pojo.User 　dao层接口返回值null\n参考链接：\n1. [参考链接1](https://www.cnblogs.com/xxjcai/p/11664315.html) 2. [参考链接2](http://www.cppcns.com/ruanjian/java/366275.html)  ","permalink":"https://init.best/posts/mybatis-return-empty/","summary":"Mybatis 不同类型返回值记录","title":"Mybatis Return Empty"},{"content":"Java Optional 使用Optional建模 public class Person { //人可能有车，也可能没 有车，因此将这个字段 声明为Optional  private Optional\u0026lt;Car\u0026gt; car; public Optional\u0026lt;Car\u0026gt; getCar() {return car;} } public class Car { // 车可能进行了保险，也可 能没有保险，所以将这个 字段声明为Optional  private Optional\u0026lt;Insurance\u0026gt; insurance; public Optional\u0026lt;Insurance\u0026gt; getInsurance() { return insurance; } } public class Insurance { //保险公司必 须有名字  private String name; public String getName() { return name; } } Optional使用 创建Optional对象 1. 声明一个空的Optional Optional\u0026lt;Car\u0026gt; optCar = Optional.empty(); 2. 依据一个非空值创建Optional 使用静态工厂方法Optional.of，依据一个非空值创建一个Optional对象:\nOptional\u0026lt;Car\u0026gt; optCar = Optional.of(car); 如果car为null，则会抛出NullPointerException\n3.可接受null的Optional 使用静态工厂方法Optional.ofNullable,允许null值的Optional对象\nOptional\u0026lt;Car\u0026gt; optCar = Optional.ofNullable(car); 使用map从Optional对象中提取和转换值 以前对null的判断：\nString name = null; if(insurance != null) { name = insurance.getName(); } 使用Optinal提供的map方法：\nOptional\u0026lt;Insurance\u0026gt; optInsurance = Optional.ofNullable(insurance); Optional\u0026lt;String\u0026gt; name = optInsurance.map(Insurance::getName); 使用flatMap链接Optional对象 错误实现：\nOptional\u0026lt;Person\u0026gt; optPerson = Optional.of(person); Optional\u0026lt;String\u0026gt; name = optPerson.map(Person::getCar) .map(Car::getInsurance) .map(Insurance::getName); 原因：\n optPerson是Optional类型的 变量， 调用map方法应该没有问题。但getCar返回的是一个Optional类型的对象(如代 码清单10-4所示)，这意味着map操作的结果是一个Optional\u0026lt;Optional\u0026gt;类型的对象。因 此，它对getInsurance的调用是非法的，因为最外层的optional对象包含了另一个optional 对象的值，而它当然不会支持getInsurance方法。\n 使用flatMap实现：\npublic String getCarInsuranceName(Optional\u0026lt;Person\u0026gt; person) { return person.flatMap(Person::getCar) .flatMap(Car::getInsurance) .map(Insurance::getName) .orElse(\u0026#34;Unknown\u0026#34;); } 最终返回的为Optional:\n默认行为及解引用Optional对象    get()是这些方法中最简单但又最不安全的方法。如果变量存在，它直接返回封装的变量 值，否则就抛出一个NoSuchElementException异常。所以，除非你非常确定Optional 变量一定包含值，否则使用这个方法是个相当糟糕的主意。此外，这种方式即便相对于 嵌套式的null检查，也并未体现出多大的改进。\n  orElse(T other)是我们在代码清单10-5中使用的方法，正如之前提到的，它允许你在 Optional对象不包含值时提供一个默认值。\n  orElseGet(Supplier\u0026lt;? extends T\u0026gt; other)是orElse方法的延迟调用版，Supplier 方法只有在Optional对象不含值时才执行调用。如果创建默认值是件耗时费力的工作， 你应该考虑采用这种方式(借此提升程序的性能)，或者你需要非常确定某个方法仅在 Optional为空时才进行调用，也可以考虑该方式(这种情况有严格的限制条件)。\n  orElseThrow(Supplier\u0026lt;? extends X\u0026gt; exceptionSupplier)和get方法非常类似， 它们遭遇Optional对象为空时都会抛出一个异常，但是使用orElseThrow你可以定制希 望抛出的异常类型。\n  ifPresent(Consumer\u0026lt;? super T\u0026gt;)让你能在变量值存在时执行一个作为参数传入的 方法，否则就不进行任何操作。\n   两个Optional对象的组合 假设有这样一个方法，它接受一个Person和一个Car对象，并以此为条件对外\n部提供的服务进行查询，通过一些复杂的业务逻辑，试图找到满足该组合的最便宜的保险公司:\npublic Insurance findCheapestInsurance(Person person, Car car) { // 不同的保险公司提供的查询服务  // 对比所有数据  return cheapestCompany; } 安全版本：\npublic Optional\u0026lt;Insurance\u0026gt; nullSafeFindCheapestInsurance( Optional\u0026lt;Person\u0026gt; person, Optional\u0026lt;Car\u0026gt; car) { if (person.isPresent() \u0026amp;\u0026amp; car.isPresent()) { return Optional.of(findCheapestInsurance(person.get(), car.get())); } else { return Optional.empty(); } } 这样写的话，跟之前的判断null很相似，可以通过前面的map和flatMap方法进行改造：\npublic Optional\u0026lt;Insurance\u0026gt; nullSafeFindCheapestInsurance( Optional\u0026lt;Person\u0026gt; person, Optional\u0026lt;Car\u0026gt; car) { return person.flatMap(p -\u0026gt; car.map(c -\u0026gt; findCheapestInsurance(p, c))); }  这段代码中，你对第一个Optional对象调用flatMap方法，如果它是个空值，传递给它 的Lambda表达式不会执行，这次调用会直接返回一个空的Optional对象。反之，如果person 对象存在，这次调用就会将其作为函数Function的输入，并按照与flatMap方法的约定返回 一个Optional对象。这个函数的函数体会对第二个Optional对象执行map操 作，如果第二个对象不包含car，函数Function就返回一个空的Optional对象，整个 nullSafeFindCheapestInsuranc方法的返回值也是一个空的Optional对象。最后，如果 person和car对象都存在，作为参数传递给map方法的Lambda表达式能够使用这两个值安全 地调用原始的findCheapestInsurance方法，完成期望的操作。\n 使用filter过滤 正常代码：\nInsurance insurance = ...; if(insurance != null \u0026amp;\u0026amp; \u0026#34;CambridgeInsurance\u0026#34;.equals(insurance.getName())){ System.out.println(\u0026#34;ok\u0026#34;); } 使用Optional重构：\nOptional\u0026lt;Insurance\u0026gt; optInsurance = ...; optInsurance.filter(insurance -\u0026gt; \u0026#34;CambridgeInsurance\u0026#34;.equals(insurance.getName())) .ifPresent(x -\u0026gt; System.out.println(\u0026#34;ok\u0026#34;)); 总结 实际使用 用Optional封装可能为null的值 例如：\nOptional\u0026lt;Object\u0026gt; value = Optional.ofNullable(map.get(\u0026#34;key\u0026#34;)); 异常与Optional的对比 在使用Integer.parseInt(String)时，如果无法解析到对应的整数，则会抛出异常，正常可以通过try/catch解决异常\n如果使用Optional的话，可以通过实现一个工具方法的方式\npublic static Optional\u0026lt;Integer\u0026gt; stringToInt(String s) { try{ return Optional.of(Integer.parseInt(s)); }catch(NumberFormatException e) { return Optional.empty(); } }  我们的建议是，你可以将多个类似的方法封装到一个工具类中，让我们称之为Optiona- 11 lUtility。通过这种方式，你以后就能直接调用OptionalUtility.stringToInt方法，将\nString转换为一个Optional对象，而不再需要记得你在其中封装了笨拙的 try/catch的逻辑了。\n ","permalink":"https://init.best/posts/java-optional/","summary":"Java Optional","title":"Java Optional"},{"content":"Mybatis之连接Mysql 环境介绍 JDK: 1.8\nMysql: 8.0.22\nMybatis: 3.5.7\n过程   下载Mybatis源码\n  新建数据库\n  在resources里面增加db.properties，对Mysql进行配置\n  增加mybatis-cofig.xml文件\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--指定配置文件--\u0026gt; \u0026lt;properties resource=\u0026#34;resources/db.properties\u0026#34;/\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;!--全局开启或关闭缓存，默认为true--\u0026gt; \u0026lt;setting name=\u0026#34;cacheEnabled\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;!--延迟加载的全局开关。可通过设置fetchType属性来覆盖该项的配置。默认值为false --\u0026gt; \u0026lt;setting name=\u0026#34;lazyLoadingEnabled\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;!--指定扫描的包--\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;org.apache.ibatis.mysqltest.pojo\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;!--环境配置--\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${driver-class-name}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!--指定Mapper.xml所在位置--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;resources/xml/BaseMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   创建对应的实体类、Mapper文件\n  测试类\n@Test public void mysqlTest() { //配置文件  String resource = \u0026#34;resources/mybatis-config.xml\u0026#34;; InputStream inputStream = null; try { inputStream = Resources.getResourceAsStream(resource); } catch (IOException e) { e.printStackTrace(); } //创建SqlSessionFactory  SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //创建SqlSession  try (SqlSession sqlSession = sqlSessionFactory.openSession()) { //获取Mapper接口的代理对象  BaseMapper mapper = sqlSession.getMapper(BaseMapper.class); List\u0026lt;User\u0026gt; u = mapper.getUsers(); //执行查询  System.out.println(u); } }   对应文件结构 ","permalink":"https://init.best/posts/mybatis-connects-mysql/","summary":"Mybatis connects Mysql","title":"Mybatis connects Mysql"},{"content":"Blog 成功转移时间：20210817 01:19\n","permalink":"https://init.best/about/","summary":"about","title":"About"},{"content":"基础类 Dish\npublic class Dish { private final String name; private final boolean vegetarian; private final int calories; private final Type type; public Dish(String name, boolean vegetarian, int calories, Type type) { this.name = name; this.vegetarian = vegetarian; this.calories = calories; this.type = type; } public String getName() { return name; } public boolean isVegetarian() { return vegetarian; } public int getCalories() { return calories; } public Type getType() { return type; } @Override public String toString() { return name; } public enum Type { MEAT, FISH, OTHER } } menu\nList\u0026lt;Dish\u0026gt; menu = Arrays.asList( new Dish(\u0026#34;pork\u0026#34;, false, 800, Dish.Type.MEAT), 3 new Dish(\u0026#34;beef\u0026#34;, false, 700, Dish.Type.MEAT), new Dish(\u0026#34;chicken\u0026#34;, false, 400, Dish.Type.MEAT), new Dish(\u0026#34;french fries\u0026#34;, true, 530, Dish.Type.OTHER), new Dish(\u0026#34;rice\u0026#34;, true, 350, Dish.Type.OTHER), new Dish(\u0026#34;season fruit\u0026#34;, true, 120, Dish.Type.OTHER), new Dish(\u0026#34;pizza\u0026#34;, true, 550, Dish.Type.OTHER), new Dish(\u0026#34;prawns\u0026#34;, false, 300, Dish.Type.FISH), 5 new Dish(\u0026#34;salmon\u0026#34;, false, 450, Dish.Type.FISH) ); 基础功能 筛选某一属性 List\u0026lt;Dish\u0026gt; vegetarianMenu = menu.stream() .filter(Dish::isVegetarian) .collect(toList()); 筛选去重 List\u0026lt;Integer\u0026gt; nembers = Arrays.asList(1,2,1,3,3,2,4); numbers.stream() .filter(i -\u0026gt; i%2==0) .distinct() .forEach(System.out::println); 限制条数 limit可以用在无序流或者有序流，无序流不会按照任何顺序排序。\nList\u0026lt;Dish\u0026gt; dishes = menu.stream() .filter(d -\u0026gt; d.getCalories() \u0026gt; 300) .limit(3) .collect(toList()); 跳过前N个元素 List\u0026lt;Dish\u0026gt; dishes = menu.stream() .filter(d -\u0026gt; d.getCalories \u0026gt;300) .skip(2) .collect(toList()); 映射 流的扁平化 例如[\u0026ldquo;Helllo\u0026rdquo;,\u0026ldquo;World\u0026rdquo;]，将字母去重之后，返回[\u0026ldquo;H\u0026rdquo;,\u0026ldquo;e\u0026rdquo;,\u0026ldquo;l\u0026rdquo;, \u0026ldquo;o\u0026rdquo;,\u0026ldquo;W\u0026rdquo;,\u0026ldquo;r\u0026rdquo;,\u0026ldquo;d\u0026rdquo;]\n如果使用：\nwords.stream() .map(word -\u0026gt; word.splot(\u0026#34;\u0026#34;)) .distinct() .collect(toList()); map返回的其实是Stream\u0026lt;String[]\u0026gt;类型，比较的是Hello与World的不同\n如果使用：\nwords.stream() .map(word -\u0026gt; word.split(\u0026#34;\u0026#34;)) .map(Arrays::stream) .distinct() .collect(toList()); 这代表，map将所有单个的字符转化为一个流，每个流中只存在一个字符\n使用flatMap得到正确结果\nwords.stream() .map(word -\u0026gt; word.split(\u0026#34;\u0026#34;)) .flatMap(Array::stream) .distinct() .collect(Collectors.toList()); flatMap将会将所有单个的流合成一个流\n查找和匹配 使用allMatch、anyMatch、noneMatch、findFirst和findAny方法进行匹配查找\nanyMatch方法 流中是否有一个元素能够匹配给定的谓词\nif(menu.stream().anyMatch(Dish::isVegetarian)){ //anymatch方法返回一个boolean类型 \tSystem.out.println(\u0026#34;The menu is (somewhat) vegetarian friendly!!\u0026#34;); } allMatch方法 流中的所有元素是否都能匹配给定的谓词\nboolean isHealthy = menu.stream() .allMatch(d -\u0026gt; d.getCalories \u0026lt;1000); noneMatch方法 流中所有元素都无法与给定的谓词匹配\nboolean isHealthy = menu.stream() .noneMatch(d -\u0026gt; d.getCalories \u0026lt;1000);  短路求值\n有些操作不需要处理整个流就能得到结果。例如，假设你需要对一个用and连起来的大布 尔表达式求值。不管表达式有多长，你只需找到一个表达式为false，就可以推断整个表达式 将返回false，所以用不着计算整个表达式。这就是短路。\n对于流而言，某些操作(例如allMatch、anyMatch、noneMatch、findFirst和findAny) 不用处理整个流就能得到结果。只要找到一个元素，就可以有结果了。同样，limit也是一个 短路操作:它只需要创建一个给定大小的流，而用不着处理流中所有的元素。在碰到无限大小 的流的时候，这种操作就有用了:它们可以把无限流变成有限流。我们会在5.7节中介绍无限 流的例子。\n findAny方法 返回流中任意元素，一般与其他流操作结合使用，则立即利用短路返回\nOptional\u0026lt;Dish\u0026gt; dish = menu.stream() .filter(Dish::isVegetarian) .findAny(); 关于Optiona简单介绍  Optiona isPresent()将在Optional包含值的时候返回true, 否则返回false。 ifPresent(Consumerblock)会在值存在的时候执行给定的代码块。Consumer函数式接口让你传递一个接收T类型参数，并返回void的Lambda表达式。\nT get()会在值存在时返回值，否则抛出一个NoSuchElement异常。 T orElse(T other)会在值存在时返回值，否则返回一个默认值。\n例如：\n menu.stream() .filter(Dish::isVegetarian) .findAny() .isPresent(d -\u0026gt; System.out.println(d.getName)); findFirst()方法 查找第一个元素，例如List中数据已经排好序，则根据短路返回第一个\nList\u0026lt;Integer\u0026gt; someNumbers = Arrays.asList(1, 2, 3, 4, 5); Optional\u0026lt;Integer\u0026gt; firstSquareDivisibleByThree = someNumbers.stream() .map(x -\u0026gt; x*x) .filter(x -\u0026gt; x%3 ==0) .findFirst(); findfirst与findAny  你可能会想，为什么会同时有findFirst和findAny呢?答案是并行。找到第一个元素 在并行上限制更多。如果你不关心返回的元素是哪个，请使用findAny，因为它在使用并行流 时限制较少。\n 归约 使用reduce操作来表达更复杂的查询，比如“计算菜单中的总卡路里”或“菜单中卡路里最高的菜是哪一个”。此类查询需要将流中所有元素反复结合起来，得到一个值，比如一个Integer。这样的查询可以被归类为归约操作 (将流归约成一个值)。用函数式编程语言的术语来说，这称为折叠(fold)，因为你可以将这个操 作看成把一张长长的纸(你的流)反复折叠成一个小方块，而这就是折叠操作的结果。\n元素求和 //求和 int sum = numbers.stream().reduce(0, (a, b) -\u0026gt; a+b); //相乘 int product = numbers.stream().reduce(1,(a, b) -\u0026gt; a*b); Java 8中，Integer类增加sum静态方法来求和\nint sum = numbers.stream().reduce(0, Integer::sum); 无初始值\nOptional\u0026lt;Integer\u0026gt; sum = numbers.stream().reduce((a, b) -\u0026gt; a+b); 因为可能不存在值，所以返回的为Optional对象。\n最大值和最小值 //最大值 Optional\u0026lt;Integer\u0026gt; max = number.stream().reduce(Integer::max); Optional\u0026lt;Integer\u0026gt; min = number.stream().reduce(Integer::min); 小总结 数值流 Java 8引入三个原始类型特化流接口，IntStream、DoubleStream、LongStream. 从而避免暗中装箱的成本。\n映射到数值流 通过mapToInt、mapToDouble、mapToLong，例如：\nint calories = menu.stream().mapToInt(Dish::getCalories).sum(); 此处mapToInt并不是返回一个Stream,而是IntStream，最终调用IntStream接口的sum()方法。\n数值流到非特化流 例如：\nIntStream intStream = menu.stream().mapToInt(Dish::getCalories); List\u0026lt;Integer\u0026gt; stream = intStream.boxed(); 默认值OptionalInt Optional同样有特化版本：OptionalInt、OptionalDouble和OptionalLong\nOptional maxCalories = menu.stream() .mapToInt(Dish::getCalories) .max(); //如果没有最大值，显式提供一个默认最大值 int max = maxCalories.orElse(1); 数值范围 Java 8 引入了两个用于IntStream和LongSteram的静态方法生成一段连续数字，例如1-100\n其中range是不包含结束值的，rangeClosed则包含结束值\n//从1到100的50个偶数 IntStream evenNumbers = IntStream.rangeClosed(1,100); .filter(n -\u0026gt; n%2 ==0); 构建流 值创建流 Stream\u0026lt;String\u0026gt; str = Stream.of(\u0026#34;Java 8\u0026#34;, \u0026#34;Lambda\u0026#34;,\u0026#34;In\u0026#34;,\u0026#34;Action\u0026#34;); str.map(String::toUpperCase).forEach(System.out.println); 生成一个空流\nStream\u0026lt;String\u0026gt; str = Stream.empty(); 数组创建流 使用静态方法Arrays.stream从数组创建一个流，它接受一个数组作为参数\nint[] numbers = {2, 3, 4, 5, 6}; int sum = ArrayList.stream(numbers).sum(); 文件生成流 //筛选不同的单词的总数 long uniqueWords = 0; //流会自动关闭 try(Stream\u0026lt;String\u0026gt; lines = Files.lines(Paths.get(\u0026#34;data.txt\u0026#34;), Charset.defaultCharset())) { uniqueWords = lines.flatMap(line -\u0026gt; Arrays.stream(line.split(\u0026#34; \u0026#34;))).distinct() .count(); }catch(IOException e) { //如果打开文件时出现异常 } 注意：flatMap的使用\n无限流简单使用 使用iterate生成 Stream.iterate(0,n -\u0026gt; n+2) .limit(10) .foreach(System.out.println); 使用generate生成 Stream.generate(Math::random) .limit(5) .forEach(System.out::println); 用流收集数据 生成Map Map\u0026lt;Currency, List\u0026lt;Transaction\u0026gt;\u0026gt; transactionsByCurrencies = transactions.stream().collect(groupingBy(Transaction::getCurrency)); 查找流中最大值和最小值 Comparator\u0026lt;Dish\u0026gt; dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories); Optional\u0026lt;Dish\u0026gt; mostCalories = menu.stream().collect(maxBy(dishCaloriesComparator)); 汇总 求和 int totalCalories = menu.stream().collect(summingInt(Dish::getCalories)); 类似的方法还有：summingLong、summingDouble\n平均数 int averageCalories = menu.stream().collect(averagingInt(Dish::getCalories)); 个数、总和、平均值、最大值、最小值 IntSummaryStatistics menuStatistics = menu.stream().collect(summarizingInt(Dish::getCalories)); 同样存在DoubleSummaryStatistics、LongSummaryStatistics\n连接字符串 String shortMenu = menu.stream().map(Dish::getName).collect(join()); 如果Dish类存在一个toString方法返回菜肴名称，则不需要进行map筛选名称变量\nString shortName = menu.stream().collect(join()); 分割方法：\nString shortName = menu.stream().map(Dish::getCalories).collect(join(\u0026#34;,\u0026#34;)); 分组 通过条件划分：\npublic enum CaloricLevel { DIEF, NORMAL, FAT} Map\u0026lt;CaloricLevel, List\u0026lt;Dish\u0026gt; dishesByCaloriesLevel = menu.stream().collect( groupBy(dish -\u0026gt; { if(dish.getCalories()\u0026lt;=400) return CaloricLevel.DIEF; else if(dish.getCalories()\u0026lt;=700) return CaloricLevel.NORMAL; else return CaloricLevel.FAT; })) 多级分组 public enum CaloricLevel { DIEF, NORMAL, FAT} Map\u0026lt;Dish.Type, Map\u0026lt;CaloricLevel, List\u0026lt;Dish\u0026gt;\u0026gt; dishesByTypeCaloricLevel = menu.stream().collect( groupingBy(Dish::getType, groupingBy(dish -\u0026gt; { if(dish.getCalories()\u0026lt;=400) return CaloricLevel.DIEF; else if(dish.getCalories()\u0026lt;=700) return CaloricLevel.NORMAL; else return CaloricLevel.FAT; }))) 按子组收集数据 1. 把收集器的结果转换为另一种类型 Map\u0026lt;Dish.Type, Long\u0026gt; typesCount = menu.stream().collect( groupingBy(Dish::getType, counting())); //结果： {MEAT=3, FISH=2, OTHER=4} 此外，gorupingBy(x)是groupingBy(x, toList())的简便写法。\n//按类型分类，得出分组中热量最高的 Map\u0026lt;Dish.Type, Optional\u0026lt;Dish\u0026gt;\u0026gt; mostCaloricByType = menu.stream() .collect(groupingBy(Dish::getType, maxBy(comparingInt(Dish::getCalories)))); //结果：{FISH=Optional[salmon], OTHER=Optional[pizza], MEAT=Optional[pork]} 注意：\n 这个Map中的值是Optional，因为这是maxBy工厂方法生成的收集器的类型，但实际上， 如果菜单中没有某一类型的Dish，这个类型就不会对应一个Optional. empty()值， 而且根本不会出现在Map的键中。groupingBy收集器只有在应用分组条件后，第一次在 流中找到某个键对应的元素时才会把键加入分组Map中。这意味着Optional包装器在这 里不是很有用，因为它不会仅仅因为它是归约收集器的返回类型而表达一个最终可能不 存在却意外存在的值。\n 去掉Optional：\nMap\u0026lt;Dish.Type, Dish\u0026gt; mostCaloricByType = menu.stream().collect(groupingBy(Dish::getType, collectingAndThen( maxBy(comparingInt(Dish::getCalories)), Optional::get))); //结果：{FISH=salmon, OTHER=pizza, MEAT=pork}  这个工厂方法接受两个参数——要转换的收集器以及转换函数，并返回另一个收集器。这个 收集器相当于旧收集器的一个包装，collect操作的最后一步就是将返回值用转换函数做一个映 射。在这里，被包起来的收集器就是用maxBy建立的那个，而转换函数Optional::get则把返 回的Optional中的值提取出来。前面已经说过，这个操作放在这里是安全的，因为reducing 收集器永远都不会返回Optional.empty()。\n 2. 与groupingBy联合使用的其他收集器的例子 将List变为Set\nMap\u0026lt;Dish.Type, Set\u0026lt;CaloricLevel\u0026gt;\u0026gt; caloricLevelsByType = menu.stream().collect( groupingBy(Dish::getType, mapping( dish -\u0026gt; { if (dish.getCalories() \u0026lt;= 400) return CaloricLevel.DIET; else if (dish.getCalories() \u0026lt;= 700) return CaloricLevel.NORMAL; else return CaloricLevel.FAT; }, toSet()))); 如果需要设置Set的类型，可以通过toCollection\nMap\u0026lt;Dish.Type, Set\u0026lt;CaloricLevel\u0026gt;\u0026gt; caloricLevelsByType = menu.stream().collect( groupingBy(Dish::getType, mapping( dish -\u0026gt; { if (dish.getCalories() \u0026lt;= 400) return CaloricLevel.DIET; else if (dish.getCalories() \u0026lt;= 700) return CaloricLevel.NORMAL; else return CaloricLevel.FAT; }, toCollection(HashSet::new)))); 分区 分区为分组的特殊情况，其会分为true和false两组\nMap\u0026lt;Boolean, List\u0026lt;Dish\u0026gt;\u0026gt; partitionedMenu = menu.stream().collect(partitioningBy(Dish::isVegetarian)); //结果：{false=[pork, beef, chicken, prawns, salmon],true=[french fries, rice, season fruit, pizza]} 分区进阶\nMap\u0026lt;Boolean, Map\u0026lt;Dish.Type, List\u0026lt;Dish\u0026gt;\u0026gt;\u0026gt; vegetarianDishesByType = menu.stream().collect( partitioningBy(Dish::isVegetarian, groupingBy(Dish::getType))); //结果：{false={FISH=[prawns, salmon], MEAT=[pork, beef, chicken]},true={OTHER=[french fries, rice, season fruit, pizza]}} 得到热量最高\nMap\u0026lt;Boolean, Dish\u0026gt; mostCaloricPartitionedByVegetarian = menu.stream().collect( partitioningBy(Dish::isVegetarian, collectingAndThen( maxBy(comparingInt(Dish::getCalories)), Optional::get))); 将数字按质数和非质数分区 有需要可继续看此部分\n收集器接口 有需要可继续看此部分\n并行流 public static long parallelSum(long n) { return Stream.iterate(1L, i -\u0026gt; i+1) .limit(n) .parallel() .reduce(0L, Long::sum); } 并行流线程池：\n并行流内部使用了默认的ForkJoinPool，它默认的线程数量就是你的处理器的数量，这个值是由Runtime.getRuntime().available-Processors()得到的。\n可以通过：\nSystem.setProperty(\u0026#34;java.util.concurrent.ForkJoinPool.common.parallelism\u0026#34;,\u0026#34;12\u0026#34;);  这是一个全局设置，因此它将影响代码中所有的并行流。反过来说，目前还无法专为某个 并行流指定这个值。一般而言，让ForkJoinPool的大小等于处理器数量是个不错的默认值， 除非你有很好的理由，否则我们强烈建议你不要修改它。\n 并行流注意：\n  留意装箱。自动装箱和拆箱操作会大大降低性能。Java 8中有原始类型流(IntStream、 LongStream、DoubleStream)来避免这种操作，但凡有可能都应该用这些流。\n  有些操作本身在并行流上的性能就比顺序流差。特别是limit和findFirst等依赖于元 素顺序的操作，它们在并行流上执行的代价非常大。例如，findAny会比findFirst性 能好，因为它不一定要按顺序来执行。你总是可以调用unordered方法来把有序流变成 无序流。那么，如果你需要流中的n个元素而不是专门要前n个的话，对无序并行流调用 limit可能会比单个有序流(比如数据源是一个List)更高效。\n  对于较小的数据量，选择并行流几乎从来都不是一个好的决定。并行处理少数几个元素 的好处还抵不上并行化造成的额外开销。\n  要考虑流背后的数据结构是否易于分解。例如，ArrayList的拆分效率比LinkedList 高得多，因为前者用不着遍历就可以平均拆分，而后者则必须遍历。另外，用range工厂方法创建的原始类型流也可以快速分解。\n  考虑终端操作中合并步骤的代价是大是小(例如Collector中的combiner方法)。如果这一步代价很大，那么组合每个子流产生的部分结果所付出的代价就可能会超出通过并行流得到的性能提升。\n  ","permalink":"https://init.best/posts/java-stream/","summary":"Java stream apply","title":"Java stream"},{"content":"Mac software recommend\n   Software Name Function     Clash Pro \u0026hellip;   Telegram \u0026hellip;   Bob translation   Adblock plus Safari Extension   MacZip compress software   JSONPeep Safari Extension   Mounty Mobile HDD   Skim PDF reader   Hidden Bar Just like its name   Mini Calendar Calendar   IINA Player   Idea development   LyricsX lyrics   Sourcetree git tool   iHosts change host quickly   Gridea blog tool   Sourcetrail watch the code   Sequel Ace database tool   Moon FM FM   qBittorent bt   AppCleaner clean your mac when you delete software   Discord    NeatDownloadManager download tool   electerm SSH   VS Code ide   Typora markdown tool   RabiAPI API tool   Google Chrome    paw API tool   Reeder Rss Reader   iTerm terminal   Stats little tool   ublacklist for Safari Safari extension   Obsidian markdown tool   Snipaste litte tool   Logseq note tool   WPS    IDEA CE    FastClip copy tool   Charles get information   Dbeaver database tool   Zotero manage tool   Another Redis Desktop Manager redis UI   dbKoda mongoldb UI   balenaEtcher Flash OS images to SD cards \u0026amp; USB drives    ","permalink":"https://init.best/posts/macos-software/","summary":"Mac software recommend","title":"Mac software recommend"}]