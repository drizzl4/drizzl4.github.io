---
title: "数据密集型应用系统设计笔记"
date: 2022-03-30T00:17:51+08:00
# aliases: ["/first"]
author: "drizzl4"
# author: ["Me", "You"] # multiple authors
TocOpen: false
draft: false
hidemeta: false
canonicalURL: "https://canonical.url/to/page"
disableHLJS: true # to disable highlightjs
disableShare: false
disableHLJS: false
hideSummary: false
ShowReadingTime: true
ShowBreadCrumbs: false
ShowPostNavLinks: true
cover:
    image: "<image path/url>" # image path/url
    alt: "<alt text>" # alt text
    caption: "<text>" # display caption under cover
    relative: false # when using page bundles set this to true
    hidden: true # only hide on current single page
editPost:
    URL: "https://github.com/drizzl4/drizzl4.github.io/blob/master/content"
    Text: "Edit" # edit text
    appendFilePath: true # to append file path to Edit link

# weight: 1
tags: ["note"]
categories: ["note"]
showToc: true
comments: false
description: "Don't be serious"
searchHidden: false
summary: ""
---

# 第一章 可扩展与可维护的应用系统

## 一、什么是“数据密集型应用系统”？

当今许多新型应用都属于数据密集型( data-intensi ve)，而不是计算密集型 (compute-intensive)。对于这些类型应用， CPU的处理能力往往不是第一限制性因素，关键在于数据量、数据的复杂度及数据的快速多变性。

而我们平时遇到的大部分系统都是数据密集型，其过程都是代码访问内存、数据库中的数据，经过业务逻辑处理，最后返回给用户。

### 1、应用系统一般包含的模块

* 数据库:用以存储数据，这样之后应用可以再次面问。
* 高速缓存 : 缓存那些复杂或操作代价昂贵的结果，以加快下一次访问。
* 索引 : 用户可以按关键字搜索数据井支持各种过掳 。
* 流式处理:持续发送消息至另 一 个进程，处理采用异步方式。
* 批处理 : 定期处理大量的累积数据。

### 2、通用的系统架构

![img](https://3811707129-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2Fplainchant%2F-MCexl-wRYNTOJqyjxqF%2F-MCexqJhziB8hCDrmV1L%2F28105543.png?generation=1595227470367300&alt=media)

### 3、软件系统极为重要的三个问题

* 可靠性
	容忍硬件/软件失效，人为的错误
	
* 可扩展性
	可扩展性是用来描述系统应对负载增加能力
	
* 可维护型

  可运维、简单、可演化性

#### 3.1 延迟与响应时间的不同
1. 响应时间为请求时间+来回网络延迟+排队延迟
2. 延迟为请求花费在处理上的时间

#### 3.2 百分位数

通常平均响应时间的计算为将n个值相加并除以n，然后因为请求不同或请求数据不同，无法告诉有多少用户实际经历了多少延迟。

因此最好使用百分位数( percen ti Jes) 。如果已经搜集到了响应 时间 信息，将其从最 快到最慢排序，中位数( median)就是列表中间的响应时间。例如，如果中位数响应 时间为200 ms，那意味着有一半的请求响应不到200 ms，而另一半请求则需要更长的时间。

中位数指标非常适合描述多少用户需要等待多长时间: 一半的用户请求的服务时间少 于中位数响应时间，另 一半则多于中位数的时间。因 此中 位数也称为 50百分位数，有 时缩 写为 p50。

采用较高的响应时间百分位数(tail latencies，尾部延时或长尾效应)很重要，因为它们直接影响用户的总体服务体验。亚马逊注意到，响应时间每增加100ms，销售额就会下降1%，其他研究则表明，1s的延时增加等价于让客户满意度下降16%。

#### 3.3 批处理系统与线性系统

在批处理系统中，我们通常关心吞吐量(throughput)，即每秒可处理的记录条数，或者在某指定数据集上运行作业所需的总时间；而在线性系统中通常更看重服务的响应时间(response time)，即客户端从发出请求到接收响应之间的间隔。

# 第二章 数据模型与查询语言

本章大量篇幅是对各种数据模型的介绍，开阔视野，在平常的开发中，对于数据存储的选择还是需要进一步调研，选择合适的数据库。

## 一、数据库模型

### 1.网络模型（已经被抛弃）

CODASYL模型是层次模型的推广。在层次模型的树结构中 ，每个记录只有一个父结点;而在网络模型中， 一个记录可能有多个父结点 。 例如， “大西雅图地区”可能有 一个记录，居住在该地区的每个用户都链接指向 它。从而支持对多对一和多对多的关 系进行建模。

其访问方式，像是遍历链表 : 从链表的头部开始， 一次查看一个记 录，直到找到所需的记录。 但是在一个多对多关系的世界里，存在多条不同的路径通 向相同的记录，使用网络模型的程序员必须在脑海中设毡跟踪这些不同的访问路径。

### 2.关系模型

关系模型所做的则是定义了所有数据的格式:关系(表)只是元组(行) 的集合

### 3.文档数据库

文档数据库是某种方式的层次模型 : 即在其父记录中保存了嵌套记录，而不是存 储在单独的表中。

## 二、一对多

以user表为例，其实现方式：

* 在传统的SQL模型(SQL: 1999之前)中， 最常见的规范化表示是将职位、教育 和联系信息放在单独的 表中 ， 并二使用外键引用 users表。
* 之后的 SQL标准增加了对结构化数据类型和 XML数据的支持。这允许将多值数据存储在单行内 ，并支持在这些文档中查询和索引。 一些数据库也支持JSON数据类型，例如IBM DB2、 MySQL和PostgreSQL。
* 第三个选项是将工作、教育和联系信息编码为JSON或XML文档，将其存储在数 据库的文本列中，并由应用程序解释其结构和内容。对于此方峙，通常不能使用 数据库查询该编码列中的值。

在存储用户的部分信息，例如：地区或行业，使用对应的码值，而不是字符串进行存储，含义：

* 避免歧义(例如，如果存在一些同名的城市)。
* 易于更新:名字只保存一次，因此，如果需要改变，可以很容易全面更新。
* 本地化支持:当网站被翻译成其他语言时，标准化的列表可以方便本地化，因此 地 区和行业可以用 查看者的母语来显示 。
* 更好的搜索支持:例如，搜索华盛顿 州的慈善 家可以匹配到过个简历，这是因为地区列表可以将西雅图属于华盛顿的信息编码进来(而从“大西雅图地区”字符 串中并不能看出来西雅图属于华盛顿) 。

## 三、关系数据库与文档数据库

如果应用数据具有类似文档的结构(即一对多关系树，通常一次加载整个树) ， 那么使用文档模型更为合适。而关系型模型则倾向于某种数据分解，它把文档结构分解为多个表，有可能使得模式更为笨重，以及不必要的应用代码复杂化。

文档模型也有 一 定的局限性：例如， 不能直接引用文档中的嵌套项，而需要说“用户 251的职位列表中的第二项” (非常类似于层次模型中的访问路径) 。然而，只要文档嵌套不太深，这通常不是问题。

如果程序中确实存在多对多的关系结构，那么使用文档类型数据库就不合适了，因为这需要你在应用层建立对应的联结关系，使得代码逻辑更加复杂。

## 四、额外收获

1. ALTER TABLE时，会将整张表复制，所以当表很大的时候，可能需要几分钟甚至几个小时的时间停机。
2. 在大表上进行update语句时，可以采用懒加载的方式，只有当调用的时候才进行填充。
3. 文档数据库查询数据局部性：如果数据被划分在多个表里，则需要多次索引查找来检索数据，更多的磁盘I/O操作，花费更多的时间。当文档以JSON、XML或者二进制的方式进行存储，在访问信息的时候，会访问大部分内容，则数据库通常会加载整个文档，如果应用只是访问其中的一小部分，则对于大型文档数据来讲就有些浪费。对文档进行更新时，通常会重写整个文档，而只有修改量不改变惊文档大小时， 原地覆盖更新才更有效。因此，通常建议文档应该尽量小且避免写入时增加文档大小。 这些性能方面的不利因素大大限制了文档数据库的适用场景。



# 第三章 数据存储与检索

## 一、索引

为了高效地查询数据库中的值,需要新的数据结构：索引。索引会加速查询速度，但是会使得写入速度变慢。

下面都是讨论的key-value索引

### 1.哈希索引

键值对的数据结构[key,value],最长见的如 HashMap。
现在，假设数据存储全部采用追加式的文件组成。

* 用户将数据存储在硬盘上，并且返回文件的偏移量，
* 将文件的偏移量在内存更新
* 当用户查询具体的key值时，找到文件的偏移量，读取文件数据，返回对应的值

**优点：**
- 基于内存的 key 寻址会非常快，hash(key)的时间复杂度为 1.
- 只需要一次磁盘寻址，快速的将数据加载到内存
- 可以利用文件系统的缓存无需 IO 开销

**缺点：**

- 我们采用的是追加读模式，可能存在磁盘用尽
- 随着 key 的增加，内存容量也会成为一个瓶颈
- 机器宕机重启内存数据丢失
- 并发写入时的问题，因为我们是以追加写的方式将数据存储到磁盘，无法评估每个线程写入的数据量。
- 数据的删除：还是由于数据在磁盘是以追加写的模式存储我们无法直接删除文件中的数据段

### 如何解决磁盘用尽？
一个好的解决方案是将日志分解成一定大小的段，当文件达到一定大小时就关闭它，井将后续写入到新 的段文件中。然后可以在这些段上执行压缩，压缩意味着在日志中丢弃重复的键，并且只保留每个键最近的更新。

### 数据删除

可以在用户提交删除申请的时候记录下来，在文件执行合并、压缩操作时在执行删除操作

### 2.SSTables

在哈希索引中，对日志进行压缩使用的排序规则为：按写入顺序排列，并且对于出现在日志中的同一个键，后出现的值优于之前的值。

现在，将key-value的排序规则改为，按键排序，这种排序称为“排序字符表”，或简称SSTable。它要求每个键在每个合并的段文件中只能出现一次(压缩过程已经确保了)。

**优点：**

- 合并段更加简单高效，即使文件大于可用内存。并发读取多个输入段文件，把最小的键按照排列顺序拷贝到输出文件中，如此往复，最终实现段按照键的顺序进行合并
- 根据排序的特性，在进行key查找时，不需要从头开始遍历，例如，key1<key2<key3，可以借助key1、key2的偏移量去查找key2
- 根据排序的特性，实现稀疏索引，节省磁盘空间，压缩减少I\O带宽占用

![image-20220417233742469](/images/image-20220417233742469.png)

**SSTables的构建：**

- 当写入时，将数据存入到内存当中，即内存表。
- 当内存表大于某个阀值，则将其写入到磁盘中，因为SSTable按键排序，所以写入速度很快。
- 在写入磁盘的同时，写入可以同时工作，数据将会写入到一个新的内存表实例中。
- 在查找数据时，首先在内存表中查找，然后在最新的磁盘段文件中查找，其次是次新的段文件，以此类推
- 后台进程周期性地执行段合并与压缩过程，以合并多个段文件，并丢弃那些已被覆盖或删除的值 。

### 3、B-trees

![image-20220417235808764](/images/image-20220417235808764.png)

B-Tree 将数据库分解成固定大小的快或者页，传统上为 4KB,页是内部的最小读写单元。

每个页面都可以使用地址或者位置进行标识，这样可以让一个页面引用另一个页面，类似指针，不过是指向磁盘地址，而不是内存。通过页面就可以构造如上所示的树状结构。

某一个页被指定为树的根，每次的查找都是从这个根开始。该页面包含若干个键和对子页的引用。每个孩子都负责一个连续范围内的查找，相邻引用之间的键可以只是这些范围之间的边界。

- **键的查找:**从根节点开始，根据区间查找，一层层往下查找知道找到目标值或者返回 null
- **键的更新:**首先查找到包含该键的页节点，将页节点从磁盘读回内存[这里也有可能由于缓存的原因，直接从内存中读取]然后更新键再写回磁盘
- **键的插入：**首先需要找到该键所属范围的页节点，将新建插入其中，但是如果该页节点没有足够的空间来容纳该新键则需要进行分裂，将原来的页节点分裂为两个半满的页，并且其父节点也需要更新以包含分裂之后的新的键范围。

  在页分裂时如果写入一半系统崩溃，那么会导致出现孤儿页，从而导致索引破坏，为避免这种情况，通常会在B-tree外添加额外的磁盘数据结构：预写日志（WAL），也称为重做日志。预写日志仅支持追加写入，因此速度很快，它可以在系统崩溃时恢复数据。

**B-tree优化方案**

- 一些数据库不直接覆盖页，也不用WAL恢复数据，而是使用写时复制方案：修改的页被写入不同位置，父页创建一个新版本并指向新的位置，这种方案同时有益于并发控制
- 保存键的缩略信息而不是完整信息，可以节省页空间，从而把更多的键压入页中，实现更高的分支因子，进而减少层数。
- 维护树的布局，让相邻叶子节点按顺序保存在磁盘上，通过范围读取实现预加载。但是随着树的增长，维护这个顺序也越来越难。
- 在相邻的兄弟节点之间加入指针链接，可以直接跳到相邻节点不需要回到父节点再次跳转

### 4、索引即数据

在某些情况下，从索引到堆文件的额外跳转对于读取来说意味着太多的性能损失， 因此可能希望将索引行直接存储在索引中。这被称为聚集索引。例如，在 MySQL InnoDB存储引擎中，表的主键始终是聚集索引， 二级索引引用主键（ 而不是堆文件位置) 。 在SQL Server中，可以为每个表指定一个聚集索引。

## 二、数据处理

### 1、数据仓库

![image-20220418002206364](/images/image-20220418002206364.png)

## 2、星型与雪花分析模式

![image-20220418003000463](/images/image-20220418003000463.png)

Fact_sales为事实表，事实表的每一行表示在特定时间发生的事件(这里， 每一行代表客户购买的一个产品 ) 。其他列可能会 引用其他表的外键，称为维度表，例如：dim_product。

雪花模式为星型模式的变体，在维度表中进行进一步的细分，例如：产品的品牌在另一张单独的表中。

# 第四章 数据编码与演化

